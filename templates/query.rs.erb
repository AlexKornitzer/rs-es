/*
 * Copyright 2015 Ben Ashford
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Query DSL - autogenerated at: <%= Time.now %>
// Do not edit query.rs directly.  The template file is query.rs.erb and the
// script to generate it is generate_query_dsl.rb

use std::collections::BTreeMap;

use rustc_serialize::json::{Json, ToJson};

use util::StrJoin;

// Useful macros for implementing `From` traits
macro_rules! from_exp {
    ($ft:ty, $dt:ident, $pi:ident, $ex:expr) => {
        impl From<$ft> for $dt {
            fn from($pi: $ft) -> $dt {
                $ex
            }
        }
    }
}

macro_rules! from {
    ($ft:ty, $dt:ident, $ev:ident, $pi:ident) => {
        from_exp!($ft, $dt, $pi, $dt::$ev($pi));
    };
    ($ft:ty, $dt:ident, $ev:ident) => {
        from!($ft, $dt, $ev, from);
    };
}

// A Json value that's not a structural thing - i.e. just String, i64 and f64,
// no array or object
#[derive(Clone)]
pub enum JsonVal {
    String(String),
    I64(i64),
    F64(f64)
}

impl ToJson for JsonVal {
    fn to_json(&self) -> Json {
        match self {
            &JsonVal::String(ref str) => str.to_json(),
            &JsonVal::I64(i)          => Json::I64(i),
            &JsonVal::F64(f)          => Json::F64(f)
        }
    }
}

from!(String, JsonVal, String);

impl<'a> From<&'a str> for JsonVal {
    fn from(from: &'a str) -> JsonVal {
        JsonVal::String(from.to_string())
    }
}

from!(f64, JsonVal, F64);
from!(i64, JsonVal, I64);

impl From<Filter> for Box<Filter> {
    fn from(from: Filter) -> Box<Filter> {
        Box::new(from)
    }
}

impl From<Query> for Box<Query> {
    fn from(from: Query) -> Box<Query> {
        Box::new(from)
    }
}

<%= enums['Query'] %>

<%= enums['Filter'] %>

// Match queries

<%= simple_value_enum('ZeroTermsQuery', ['none', 'all']) %>

#[derive(Clone)]
pub enum Fuzziness {
    Auto,
    LevenshteinDistance(i64),
    Proportionate(f64)
}

from!(i64, Fuzziness, LevenshteinDistance);
from!(f64, Fuzziness, Proportionate);

impl ToJson for Fuzziness {
    fn to_json(&self) -> Json {
        use self::Fuzziness::{Auto, LevenshteinDistance, Proportionate};
        match self {
            &Auto                      => "auto".to_json(),
            &LevenshteinDistance(dist) => dist.to_json(),
            &Proportionate(prop)       => prop.to_json()
        }
    }
}

<%= simple_value_enum('MatchType', ['phrase', 'phrase_prefix']) %>

<%= simple_value_enum('MatchQueryType', ['best_fields',
                                         'most_fields',
                                         'cross_fields',
                                         'phrase',
                                         'phrase_prefix']) %>

// Option structs for Query(ies)

<%= structs['MatchAllQuery'] %>
<%= to_json_impl('MatchAllQuery') %>

<%= structs['MatchQuery'] %>
<%= to_json_inner_impl('MatchQuery') %>

<%= structs['MultiMatchQuery'] %>
<%= to_json_impl('MultiMatchQuery') %>

<%= structs['BoolQuery'] %>
<%= to_json_impl('BoolQuery') %>

<%= structs['BoostingQuery'] %>
<%= to_json_impl('BoostingQuery') %>

<%= structs['CommonQuery'] %>

#[derive(Clone, Debug)]
pub struct CombinationMinimumShouldMatch {
    first: MinimumShouldMatch,
    second: MinimumShouldMatch
}

impl CombinationMinimumShouldMatch {
    pub fn new<A, B>(first: A, second: B) -> CombinationMinimumShouldMatch
        where A: Into<MinimumShouldMatch>,
              B: Into<MinimumShouldMatch>
    {
        CombinationMinimumShouldMatch {
            first:  first.into(),
            second: second.into()
        }
    }
}

impl ToString for CombinationMinimumShouldMatch {
    fn to_string(&self) -> String {
        format!("{}<{}", self.first.to_string(), self.second.to_string())
    }
}

impl ToJson for CombinationMinimumShouldMatch {
    fn to_json(&self) -> Json {
        self.to_string().to_json()
    }
}

#[derive(Clone, Debug)]
pub enum MinimumShouldMatch {
    Integer(i64),
    Percentage(f64),
    Combination(Box<CombinationMinimumShouldMatch>),
    MultipleCombination(Vec<CombinationMinimumShouldMatch>),
    LowHigh(i64, i64)
}

from!(i64, MinimumShouldMatch, Integer);
from!(f64, MinimumShouldMatch, Percentage);
from_exp!(CombinationMinimumShouldMatch,
          MinimumShouldMatch,
          from,
          MinimumShouldMatch::Combination(Box::new(from)));
from!(Vec<CombinationMinimumShouldMatch>, MinimumShouldMatch, MultipleCombination);
from_exp!((i64, i64),
          MinimumShouldMatch,
          from,
          MinimumShouldMatch::LowHigh(from.0, from.1));

impl ToString for MinimumShouldMatch {
    fn to_string(&self) -> String {
        match self {
            &MinimumShouldMatch::Integer(val) => val.to_string(),
            &MinimumShouldMatch::Percentage(val) => {
                format!("{}%", val)
            },
            _ => panic!("Can't convert {:?} to String", self)
        }
    }
}

impl ToJson for MinimumShouldMatch {
    fn to_json(&self) -> Json {
        match self {
            &MinimumShouldMatch::Integer(val) => val.to_json(),
            &MinimumShouldMatch::Percentage(_) => {
                self.to_string().to_json()
            },
            &MinimumShouldMatch::Combination(ref comb) => {
                comb.to_json()
            },
            &MinimumShouldMatch::MultipleCombination(ref combs) => {
                Json::String(combs.iter().map(|c| c.to_string()).join(" "))
            }
            &MinimumShouldMatch::LowHigh(low, high) => {
                let mut d = BTreeMap::new();
                d.insert("low_freq".to_string(), low.to_json());
                d.insert("high_freq".to_string(), high.to_json());
                Json::Object(d)
            }
        }
    }
}

impl ToJson for CommonQuery {
    fn to_json(&self) -> Json {
        let mut d = BTreeMap::new();
        let mut inner = BTreeMap::new();
        inner.insert("query".to_string(), self.query.to_json());
        self.add_optionals(&mut inner);
        d.insert("body".to_string(), inner.to_json());
        Json::Object(d)
    }
}

<%= structs['ConstantScoreQuery'] %>
<%= to_json_impl('ConstantScoreQuery') %>

<%= structs['DisMaxQuery'] %>
<%= to_json_impl('DisMaxQuery') %>

<%= structs['FilteredQuery'] %>

#[derive(Clone)]
pub enum Strategy {
    LeapFrogQueryFirst,
    LeapFrogFilterFirst,
    QueryFirst,
    RandomAccess(i64),
    RandomAccessAlways
}

from!(i64, Strategy, RandomAccess);

impl ToJson for Strategy {
    fn to_json(&self) -> Json {
        match self {
            &Strategy::LeapFrogQueryFirst  => "leap_frog_query_first".to_json(),
            &Strategy::LeapFrogFilterFirst => "leap_frog_filter_first".to_json(),
            &Strategy::QueryFirst          => "query_first".to_json(),
            &Strategy::RandomAccess(amt)   => format!("random_access_{}", amt).to_json(),
            &Strategy::RandomAccessAlways  => "random_access_always".to_json()
        }
    }
}

<%= to_json_impl('FilteredQuery') %>

<%= structs['FuzzyLikeThisQuery'] %>
<%= to_json_impl('FuzzyLikeThisQuery') %>

<%= structs['FuzzyLikeThisFieldQuery'] %>
<%= to_json_inner_impl('FuzzyLikeThisFieldQuery') %>

<%= structs['FunctionScoreQuery'] %>

<%= simple_value_enum('ScoreMode', ['multiply',
                                    'sum',
                                    'avg',
                                    'first',
                                    'max',
                                    'min']) %>
<%= simple_value_enum('BoostMode', ['multiply',
                                    'replace',
                                    'sum',
                                    'avg',
                                    'max',
                                    'min']) %>

<%= to_json_impl('FunctionScoreQuery') %>

<%= structs['FuzzyQuery'] %>
<%= to_json_inner_impl('FuzzyQuery') %>

// Required for GeoShape

#[derive(Clone)]
pub struct Shape {
    shape_type: String,
    coordinates: Vec<(f64, f64)>
}

impl Shape {
    pub fn new<A: Into<String>>(shape_type: A, coordinates: Vec<(f64, f64)>) -> Shape {
        Shape {
            shape_type:  shape_type.into(),
            coordinates: coordinates
        }
    }
}

impl ToJson for Shape {
    fn to_json(&self) -> Json {
        let mut d = BTreeMap::new();
        let mut inner = BTreeMap::new();

        inner.insert("type".to_string(), self.shape_type.to_json());

        let coordinates:Vec<Vec<f64>> = self.coordinates
            .iter()
            .map (|&(a, b)| vec![a, b])
            .collect();
        inner.insert("coordinates".to_string(), coordinates.to_json());

        d.insert("shape".to_string(), Json::Object(inner));
        Json::Object(d)
    }
}

#[derive(Clone)]
pub struct IndexedShape {
    id:       String,
    doc_type: String,
    index:    String,
    path:     String
}

impl IndexedShape {
    pub fn new<A, B, C, D>(id: A, doc_type: B, index: C, path: D) -> IndexedShape
        where A: Into<String>,
              B: Into<String>,
              C: Into<String>,
              D: Into<String>
    {
        IndexedShape {
            id: id.into(),
            doc_type: doc_type.into(),
            index: index.into(),
            path: path.into()
        }
    }
}

impl ToJson for IndexedShape {
    fn to_json(&self) -> Json {
        let mut d = BTreeMap::new();
        let mut inner = BTreeMap::new();
        inner.insert("id".to_string(), self.id.to_json());
        inner.insert("type".to_string(), self.doc_type.to_json());
        inner.insert("index".to_string(), self.doc_type.to_json());
        inner.insert("path".to_string(), self.doc_type.to_json());
        d.insert("indexed_shape".to_string(), Json::Object(inner));
        Json::Object(d)
    }
}

<%= structs['GeoShapeQuery'] %>
<%= to_json_inner_impl('GeoShapeQuery') %>

<%= structs['HasChildQuery'] %>
<%= to_json_impl('HasChildQuery') %>

<%= structs['HasParentQuery'] %>
<%= to_json_impl('HasParentQuery') %>

#[derive(Clone)]
pub enum OneOrMany<T: ToJson> {
    One(T),
    Many(Vec<T>)
}

impl<T: ToJson> From<T> for OneOrMany<T> {
    fn from(from: T) -> OneOrMany<T> {
        OneOrMany::One(from)
    }
}

impl<T: ToJson> From<Vec<T>> for OneOrMany<T> {
    fn from(from: Vec<T>) -> OneOrMany<T> {
        OneOrMany::Many(from)
    }
}

impl<T: ToJson> ToJson for OneOrMany<T> {
    fn to_json(&self) -> Json {
        match self {
            &OneOrMany::One(ref t)  => t.to_json(),
            &OneOrMany::Many(ref t) => t.to_json()
        }
    }
}

<%= structs['IdsQuery'] %>
<%= to_json_impl('IdsQuery') %>

<%= structs['IndicesQuery'] %>
<%= to_json_impl('IndicesQuery') %>

// A document can be provided as an example
#[derive(Clone)]
pub struct Doc {
    index:    String,
    doc_type: String,
    doc:      Option<Json>,
    id:       Option<String>
}

impl Doc {
    pub fn from_doc<A, B>(index: A, doc_type: B, doc: Json) -> Doc
        where A: Into<String>, B: Into<String>
    {
        Doc {
            index:    index.into(),
            doc_type: doc_type.into(),
            doc:      Some(doc),
            id:       None
        }
    }

    pub fn id<A, B, C>(index: A, doc_type: B, id: C) -> Doc
        where A: Into<String>, B: Into<String>, C: Into<String>
    {
        Doc {
            index:    index.into(),
            doc_type: doc_type.into(),
            doc:      None,
            id:       Some(id.into())
        }
    }
}

impl ToJson for Doc {
    fn to_json(&self) -> Json {
        let mut d = BTreeMap::new();
        d.insert("_index".to_string(), self.index.to_json());
        d.insert("_type".to_string(), self.doc_type.to_json());

        optional_add!(d, self.doc, "doc");
        optional_add!(d, self.id, "_id");

        Json::Object(d)
    }
}

<%= structs['MoreLikeThisQuery'] %>
<%= to_json_impl('MoreLikeThisQuery') %>

<%= structs['NestedQuery'] %>
<%= to_json_impl('NestedQuery') %>

<%= structs['PrefixQuery'] %>

#[derive(Clone)]
pub enum Rewrite {
    ConstantScoreAuto,
    ScoringBoolean,
    ConstantScoreBoolean,
    ConstantScoreFilter,
    TopTerms(i64),
    TopTermsBoost(i64)
}

impl ToJson for Rewrite {
    fn to_json(&self) -> Json {
        match self {
            &Rewrite::ConstantScoreAuto    => "constant_score_auto".to_json(),
            &Rewrite::ScoringBoolean       => "scoring_boolean".to_json(),
            &Rewrite::ConstantScoreBoolean => "constant_score_boolean".to_json(),
            &Rewrite::ConstantScoreFilter  => "constant_score_filter".to_json(),
            &Rewrite::TopTerms(n)          => format!("top_terms_{}", n).to_json(),
            &Rewrite::TopTermsBoost(n)     => format!("top_terms_boost_{}", n).to_json()
        }
    }
}

<%= to_json_inner_impl('PrefixQuery') %>

<%= structs['QueryStringQuery'] %>
<%= to_json_impl('QueryStringQuery') %>

<%= structs['SimpleQueryStringQuery'] %>
<%= to_json_impl('SimpleQueryStringQuery') %>

<%= structs['RangeQuery'] %>
<%= to_json_inner_impl('RangeQuery') %>

<%= structs['RegexpQuery'] %>

#[derive(Clone)]
pub enum Flag {
    All,
    AnyString,
    Complement,
    Intersection,
    Interval,
    None
}

impl ToString for Flag {
    fn to_string(&self) -> String {
        match self {
            &Flag::All => "ALL",
            &Flag::AnyString => "ANYSTRING",
            &Flag::Complement => "COMPLEMENT",
            &Flag::Intersection => "INTERSECTION",
            &Flag::Interval => "INTERVAL",
            &Flag::None => "NONE"
        }.to_string()
    }
}

#[derive(Clone)]
pub struct Flags {
    flags: Vec<Flag>
}

impl Flags {
    pub fn new() -> Flags {
        Flags {
            flags: vec![]
        }
    }

    pub fn add_flag(&mut self, flag: Flag) -> &mut Self {
        self.flags.push(flag);
        self
    }
}

impl ToJson for Flags {
    fn to_json(&self) -> Json {
        Json::String(self.flags.iter().map(|f| f.to_string()).join("|"))
    }
}

<%= to_json_inner_impl('RegexpQuery') %>

<%= structs['SpanFirstQuery'] %>
<%= to_json_impl('SpanFirstQuery') %>

<%= structs['SpanMultiQuery'] %>
<%= to_json_impl('SpanMultiQuery') %>

<%= structs['SpanNearQuery'] %>
<%= to_json_impl('SpanNearQuery') %>

<%= structs['SpanNotQuery'] %>
<%= to_json_impl('SpanNotQuery') %>

<%= structs['SpanOrQuery'] %>
<%= to_json_impl('SpanOrQuery') %>

<%= structs['SpanTermQuery'] %>
<%= to_json_inner_impl('SpanTermQuery') %>

<%= structs['TermQuery'] %>
<%= to_json_inner_impl('TermQuery') %>

<%= structs['TermsQuery'] %>

impl ToJson for TermsQuery {
    fn to_json(&self) -> Json {
        let mut d = BTreeMap::new();
        d.insert(self.field.clone(), self.values.to_json());

        Json::Object(d)
    }
}

<%= structs['WildcardQuery'] %>
<%= to_json_inner_impl('WildcardQuery') %>

// Filters

<%= structs['AndFilter'] %>
<%= to_json_impl('AndFilter') %>

<%= structs['BoolFilter'] %>
<%= to_json_impl('BoolFilter') %>

<%= structs['ExistsFilter'] %>
<%= to_json_impl('ExistsFilter') %>

<%= structs['GeoBoundingBoxFilter'] %>

#[derive(Clone)]
pub enum Location {
    LatLon(f64, f64),
    GeoHash(String)
}

from_exp!((f64, f64), Location, from, Location::LatLon(from.0, from.1));
from!(String, Location, GeoHash);

impl ToJson for Location {
    fn to_json(&self) -> Json {
        match self {
            &Location::LatLon(lat, lon) => {
                let mut d = BTreeMap::new();
                d.insert("lat".to_string(), Json::F64(lat));
                d.insert("lon".to_string(), Json::F64(lon));
                Json::Object(d)
            },
            &Location::GeoHash(ref geo_hash) => {
                Json::String(geo_hash.clone())
            }
        }
    }
}

#[derive(Clone)]
pub enum GeoBox {
    Corners(Location, Location),
    Vertices(f64, f64, f64, f64)
}

from_exp!((Location, Location), GeoBox, from, GeoBox::Corners(from.0, from.1));
from_exp!(((f64, f64), (f64, f64)),
          GeoBox,
          from,
          GeoBox::Corners(Location::LatLon({from.0}.0, {from.0}.1),
                          Location::LatLon({from.1}.0, {from.1}.1)));
from_exp!((f64, f64, f64, f64),
          GeoBox,
          from,
          GeoBox::Vertices(from.0, from.1, from.2, from.3));

impl ToJson for GeoBox {
    fn to_json(&self) -> Json {
        let mut d = BTreeMap::new();
        match self {
            &GeoBox::Corners(ref top_left, ref bottom_right) => {
                d.insert("top_left".to_string(), top_left.to_json());
                d.insert("bottom_right".to_string(), bottom_right.to_json());
            },
            &GeoBox::Vertices(ref top, ref left, ref bottom, ref right) => {
                d.insert("top".to_string(), top.to_json());
                d.insert("left".to_string(), left.to_json());
                d.insert("bottom".to_string(), bottom.to_json());
                d.insert("right".to_string(), right.to_json());
            }
        }
        Json::Object(d)
    }
}

impl ToJson for GeoBoundingBoxFilter {
    fn to_json(&self) -> Json {
        let mut d = BTreeMap::new();
        d.insert(self.field.clone(), self.geo_box.to_json());
        self.add_optionals(&mut d);
        self.add_core_optionals(&mut d);
        Json::Object(d)
    }
}

<%= structs['GeoDistanceFilter'] %>

// TODO - this list is incomplete
#[derive(Clone)]
pub enum DurationUnit {
    Week,
    Day,
    Hour
}

impl ToString for DurationUnit {
    fn to_string(&self) -> String {
        match *self {
            DurationUnit::Week => "w",
            DurationUnit::Day  => "d",
            DurationUnit::Hour => "h"
        }.to_string()
    }
}

#[derive(Clone)]
pub enum DistanceUnit {
    Mile,
    Yard,
    Feet,
    Inch,
    Kilometer,
    Meter,
    Centimeter,
    Millimeter,
    NauticalMile
}

impl ToString for DistanceUnit {
    fn to_string(&self) -> String {
        match *self {
            DistanceUnit::Mile => "mi",
            DistanceUnit::Yard => "yd",
            DistanceUnit::Feet => "ft",
            DistanceUnit::Inch => "in",
            DistanceUnit::Kilometer => "km",
            DistanceUnit::Meter => "m",
            DistanceUnit::Centimeter => "cm",
            DistanceUnit::Millimeter => "mm",
            DistanceUnit::NauticalMile => "NM"
        }.to_string()
    }
}

#[derive(Clone)]
pub struct Duration {
    amt: i64,
    unit: DurationUnit
}

impl Duration {
    pub fn new(amt: i64, unit: DurationUnit) -> Duration {
        Duration {
            amt: amt,
            unit: unit
        }
    }
}

impl ToJson for Duration {
    fn to_json(&self) -> Json {
        Json::String(format!("{}{}", self.amt, self.unit.to_string()))
    }
}

#[derive(Clone)]
pub struct Distance {
    amt: f64,
    unit: DistanceUnit
}

impl Distance {
    pub fn new(amt: f64, unit: DistanceUnit) -> Distance {
        Distance {
            amt:  amt,
            unit: unit
        }
    }
}

impl ToJson for Distance {
    fn to_json(&self) -> Json {
        Json::String(format!("{}{}", self.amt, self.unit.to_string()))
    }
}

<%= simple_value_enum('DistanceType', ['sloppy_arc', 'arc', 'plane']) %>
<%= simple_value_enum('OptimizeBbox', ['memory', 'indexed', 'none']) %>

impl ToJson for GeoDistanceFilter {
    fn to_json(&self) -> Json {
        let mut d = BTreeMap::new();
        d.insert(self.field.clone(), self.location.to_json());
        d.insert("distance".to_string(), self.distance.to_json());
        self.add_optionals(&mut d);
        self.add_core_optionals(&mut d);
        Json::Object(d)
    }
}

<%= structs['GeoPolygonFilter'] %>
<%= to_json_inner_impl('GeoPolygonFilter') %>

<%= structs['GeoShapeFilter'] %>
<%= to_json_inner_impl('GeoShapeFilter') %>

<%= structs['GeohashCellFilter'] %>

#[derive(Clone)]
pub enum Precision {
    Geohash(i64),
    Distance(Distance)
}

from!(i64, Precision, Geohash);
from!(Distance, Precision, Distance);

impl ToJson for Precision {
    fn to_json(&self) -> Json {
        match self {
            &Precision::Geohash(geohash_precision) => Json::I64(geohash_precision),
            &Precision::Distance(ref distance)     => distance.to_json()
        }
    }
}

impl ToJson for GeohashCellFilter {
    fn to_json(&self) -> Json {
        let mut d = BTreeMap::new();
        d.insert(self.field.clone(), self.location.to_json());
        self.add_optionals(&mut d);
        self.add_core_optionals(&mut d);
        Json::Object(d)
    }
}

<%= structs['HasChildFilter'] %>
<%= to_json_impl('HasChildFilter') %>

<%= structs['HasParentFilter'] %>
<%= to_json_impl('HasParentFilter') %>

<%= structs['IdsFilter'] %>
<%= to_json_impl('IdsFilter') %>

<%= structs['IndicesFilter'] %>

#[derive(Clone)]
pub enum NoMatchFilter {
    None,
    All,
    Filter(Box<Filter>)
}

from_exp!(Filter, NoMatchFilter, from, NoMatchFilter::Filter(Box::new(from)));

impl ToJson for NoMatchFilter {
    fn to_json(&self) -> Json {
        match self {
            &NoMatchFilter::None               => "none".to_json(),
            &NoMatchFilter::All                => "all".to_json(),
            &NoMatchFilter::Filter(ref filter) => filter.to_json()
        }
    }
}

<%= to_json_impl('IndicesFilter') %>

<%= structs['MatchAllFilter'] %>
<%= to_json_impl('MatchAllFilter') %>

<%= structs['MissingFilter'] %>
<%= to_json_impl('MissingFilter') %>

<%= structs['NestedFilter'] %>
<%= to_json_impl('NestedFilter') %>

<%= structs['NotFilter'] %>
<%= to_json_impl('NotFilter') %>

<%= structs['OrFilter'] %>
<%= to_json_impl('OrFilter') %>

<%= structs['PrefixFilter'] %>

impl ToJson for PrefixFilter {
    fn to_json(&self) -> Json {
        let mut d = BTreeMap::new();
        d.insert(self.field.clone(), self.value.to_json());
        self.add_optionals(&mut d);
        self.add_core_optionals(&mut d);
        Json::Object(d)
    }
}

<%= structs['QueryFilter'] %>
<%= to_json_impl('QueryFilter') %>

<%= structs['RangeFilter'] %>
<%= to_json_inner_impl('RangeFilter') %>

<%= structs['RegexpFilter'] %>
<%= to_json_inner_impl('RegexpFilter') %>

<%= structs['ScriptFilter'] %>
<%= to_json_impl('ScriptFilter') %>

<%= structs['TermFilter'] %>

impl ToJson for TermFilter {
    fn to_json(&self) -> Json {
        let mut d = BTreeMap::new();
        d.insert(self.field.clone(), self.value.to_json());
        self.add_optionals(&mut d);
        self.add_core_optionals(&mut d);
        Json::Object(d)
    }
}

<%= structs['TermsFilter'] %>

<%= simple_value_enum('Execution', ['plain',
                                    'fielddata',
                                    'bool',
                                    'bool_nocache',
                                    'and',
                                    'and_nocache',
                                    'or',
                                    'or_nocache']) %>

impl ToJson for TermsFilter {
    fn to_json(&self) -> Json {
        let mut d = BTreeMap::new();
        d.insert(self.field.clone(), self.values.to_json());
        self.add_optionals(&mut d);
        self.add_core_optionals(&mut d);
        Json::Object(d)
    }
}

<%= structs['TypeFilter'] %>
<%= to_json_impl('TypeFilter') %>

// Functions for use in `FunctionScoreQuery`

<%= function_enum('Func', ['script_score',
                           'random_score',
                           'field_value_factor',
                           'linear']) %>

<%= structs['ScriptScoreFunc'] %>
<%= to_json_impl('ScriptScoreFunc') %>

<%= structs['RandomScoreFunc'] %>
<%= to_json_impl('RandomScoreFunc') %>

<%= structs['FieldValueFactorFunc'] %>

<%= simple_value_enum('Modifier', ['none',
                                   'log',
                                   'log1p',
                                   'log2p',
                                   'ln',
                                   'ln1p',
                                   'ln2p',
                                   'square',
                                   'sqrt',
                                   'reciprocal']) %>

<%= to_json_impl('FieldValueFactorFunc') %>

<%= structs['LinearFunc'] %>

#[derive(Clone)]
enum Origin {
    I64(i64),
    F64(f64),
    Distance(Distance),
    Duration(Duration)
}

from!(i64, Origin, I64);
from!(f64, Origin, F64);
from!(Distance, Origin, Distance);
from!(Duration, Origin, Duration);

impl ToJson for Origin {
    fn to_json(&self) -> Json {
        match self {
            &Origin::I64(orig)          => Json::I64(orig),
            &Origin::F64(orig)          => Json::F64(orig),
            &Origin::Distance(ref orig) => orig.to_json(),
            &Origin::Duration(ref orig) => orig.to_json()
        }
    }
}

<%= to_json_inner_impl('LinearFunc') %>

#[derive(Clone)]
struct Function {
    filter: Option<Filter>,
    function: Func,
    weight: Option<f64>
}

impl ToJson for Function {
    fn to_json(&self) -> Json {
        let mut d = BTreeMap::new();
        optional_add!(d, self.filter, "filter");
        optional_add!(d, self.weight, "weight");
        d.insert(self.function.name(), self.function.to_json());
        Json::Object(d)
    }
}
