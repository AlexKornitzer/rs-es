// Query DSL - autogenerated at: <%= Time.now %>

use std::collections::BTreeMap;
use std::collections::HashMap;

use rustc_serialize::json::{Json, ToJson};

use util::StrJoin;

<%= enums['Query'] %>

<%= enums['Filter'] %>

macro_rules! with {
    ($funcn:ident, $sn:ident, $t:ty) => {
        pub fn $funcn<'a>(&'a mut self, value: $t) -> &'a mut Self {
            self.$sn = Some(value);
            self
        }
    }
}

// Match queries

<%= simple_value_enum('ZeroTermsQuery', ['none', 'all']) %>

#[derive(Clone)]
pub enum Fuzziness {
    Auto,
    LevenshteinDistance(i64),
    Proportionate(f64)
}

impl ToJson for Fuzziness {
    fn to_json(&self) -> Json {
        use self::Fuzziness::{Auto, LevenshteinDistance, Proportionate};
        match self {
            &Auto                      => "auto".to_json(),
            &LevenshteinDistance(dist) => dist.to_json(),
            &Proportionate(prop)       => prop.to_json()
        }
    }
}

<%= simple_value_enum('MatchType', ['phrase', 'phrase_prefix']) %>

<%= simple_value_enum('MatchQueryType', ['best_fields',
                                         'most_fields',
                                         'cross_fields',
                                         'phrase',
                                         'phrase_prefix']) %>

// Option structs for Query(ies)

<%= structs['MatchAllQuery'] %>
<%= to_json_impl('MatchAllQuery') %>

<%= structs['MatchQuery'] %>
<%= to_json_inner_impl('MatchQuery') %>

<%= structs['MultiMatchQuery'] %>
<%= to_json_impl('MultiMatchQuery') %>

<%= structs['BoolQuery'] %>
<%= to_json_impl('BoolQuery') %>

<%= structs['BoostingQuery'] %>
<%= to_json_impl('BoostingQuery') %>

<%= structs['CommonQuery'] %>

#[derive(Clone, Debug)]
pub struct CombinationMinimumShouldMatch {
    first: MinimumShouldMatch,
    second: MinimumShouldMatch
}

impl ToString for CombinationMinimumShouldMatch {
    fn to_string(&self) -> String {
        format!("{}<{}", self.first.to_string(), self.second.to_string())
    }
}

impl ToJson for CombinationMinimumShouldMatch {
    fn to_json(&self) -> Json {
        self.to_string().to_json()
    }
}

#[derive(Clone, Debug)]
pub enum MinimumShouldMatch {
    Integer(i64),
    Percentage(f64),
    Combination(Box<CombinationMinimumShouldMatch>),
    MultipleCombination(Vec<CombinationMinimumShouldMatch>),
    LowHigh(i64, i64)
}

impl ToString for MinimumShouldMatch {
    fn to_string(&self) -> String {
        match self {
            &MinimumShouldMatch::Integer(val) => val.to_string(),
            &MinimumShouldMatch::Percentage(val) => {
                format!("{}%", val)
            },
            _ => panic!("Can't convert {:?} to String", self)
        }
    }
}

impl ToJson for MinimumShouldMatch {
    fn to_json(&self) -> Json {
        match self {
            &MinimumShouldMatch::Integer(val) => val.to_json(),
            &MinimumShouldMatch::Percentage(_) => {
                self.to_string().to_json()
            },
            &MinimumShouldMatch::Combination(ref comb) => {
                comb.to_json()
            },
            &MinimumShouldMatch::MultipleCombination(ref combs) => {
                Json::String(combs.iter().map(|c| c.to_string()).join(" "))
            }
            &MinimumShouldMatch::LowHigh(low, high) => {
                let mut d = BTreeMap::new();
                d.insert("low_freq".to_string(), low.to_json());
                d.insert("high_freq".to_string(), high.to_json());
                Json::Object(d)
            }
        }
    }
}

impl ToJson for CommonQuery {
    fn to_json(&self) -> Json {
        let mut d = BTreeMap::new();
        let mut inner = BTreeMap::new();
        inner.insert("query".to_string(), self.query.clone());
        self.add_optionals(&mut inner);
        d.insert("body".to_string(), inner.to_json());
        Json::Object(d)
    }
}

<%= structs['ConstantScoreQuery'] %>
<%= to_json_impl('ConstantScoreQuery') %>

<%= structs['DisMaxQuery'] %>
<%= to_json_impl('DisMaxQuery') %>

<%= structs['FilteredQuery'] %>

#[derive(Clone)]
pub enum Strategy {
    LeapFrogQueryFirst,
    LeapFrogFilterFirst,
    QueryFirst,
    RandomAccess(i64),
    RandomAccessAlways
}

impl ToJson for Strategy {
    fn to_json(&self) -> Json {
        match self {
            &Strategy::LeapFrogQueryFirst  => "leap_frog_query_first".to_json(),
            &Strategy::LeapFrogFilterFirst => "leap_frog_filter_first".to_json(),
            &Strategy::QueryFirst          => "query_first".to_json(),
            &Strategy::RandomAccess(amt)   => format!("random_access_{}", amt).to_json(),
            &Strategy::RandomAccessAlways  => "random_access_always".to_json()
        }
    }
}

<%= to_json_impl('FilteredQuery') %>

<%= structs['FuzzyLikeThisQuery'] %>
<%= to_json_impl('FuzzyLikeThisQuery') %>

<%= structs['FuzzyLikeThisFieldQuery'] %>
<%= to_json_inner_impl('FuzzyLikeThisFieldQuery') %>

<%= structs['FunctionScoreQuery'] %>

<%= simple_value_enum('ScoreMode', ['multiply',
                                    'sum',
                                    'avg',
                                    'first',
                                    'max',
                                    'min']) %>
<%= simple_value_enum('BoostMode', ['multiply',
                                    'replace',
                                    'sum',
                                    'avg',
                                    'max',
                                    'min']) %>

<%= enums['Function'] %>

<%= structs['ScriptScoreFunction'] %>

<%= to_json_impl('ScriptScoreFunction') %>

<%= structs['WeightFunction'] %>

impl ToJson for WeightFunction {
    fn to_json(&self) -> Json {
        self.weight.to_json()
    }
}

<%= structs['RandomScoreFunction'] %>
<%= to_json_impl('RandomScoreFunction') %>

<%= to_json_impl('FunctionScoreQuery') %>

<%= structs['FuzzyQuery'] %>
<%= to_json_inner_impl('FuzzyQuery') %>

// Required for GeoShape

#[derive(Clone)]
pub struct Shape {
    shape_type: String,
    coordinates: Vec<(f64, f64)>
}

impl ToJson for Shape {
    fn to_json(&self) -> Json {
        let mut d = BTreeMap::new();
        let mut inner = BTreeMap::new();

        inner.insert("type".to_string(), self.shape_type.to_json());

        let coordinates:Vec<Vec<f64>> = self.coordinates
            .iter()
            .map (|&(a, b)| vec![a, b])
            .collect();
        inner.insert("coordinates".to_string(), coordinates.to_json());

        d.insert("shape".to_string(), Json::Object(inner));
        Json::Object(d)
    }
}

#[derive(Clone)]
pub struct IndexedShape {
    id: String,
    doc_type: String,
    index: String,
    path: String
}

impl ToJson for IndexedShape {
    fn to_json(&self) -> Json {
        let mut d = BTreeMap::new();
        let mut inner = BTreeMap::new();
        inner.insert("id".to_string(), self.id.to_json());
        inner.insert("type".to_string(), self.doc_type.to_json());
        inner.insert("index".to_string(), self.doc_type.to_json());
        inner.insert("path".to_string(), self.doc_type.to_json());
        d.insert("indexed_shape".to_string(), Json::Object(inner));
        Json::Object(d)
    }
}

<%= structs['GeoShapeQuery'] %>
<%= to_json_inner_impl('GeoShapeQuery') %>

<%= structs['HasChildQuery'] %>
<%= to_json_impl('HasChildQuery') %>

<%= structs['HasParentQuery'] %>
<%= to_json_impl('HasParentQuery') %>

#[derive(Clone)]
pub enum OneOrMany<T: ToJson> {
    One(T),
    Many(Vec<T>)
}

impl<T: ToJson> ToJson for OneOrMany<T> {
    fn to_json(&self) -> Json {
        match self {
            &OneOrMany::One(ref t)  => t.to_json(),
            &OneOrMany::Many(ref t) => t.to_json()
        }
    }
}

<%= structs['IdsQuery'] %>
<%= to_json_impl('IdsQuery') %>

<%= structs['IndicesQuery'] %>
<%= to_json_impl('IndicesQuery') %>

// A document can be provided as an example
#[derive(Clone)]
pub struct Doc {
    index:    String,
    doc_type: String,
    doc:      Option<Json>,
    id:       Option<String>
}

impl ToJson for Doc {
    fn to_json(&self) -> Json {
        let mut d = BTreeMap::new();
        d.insert("_index".to_string(), self.index.to_json());
        d.insert("_type".to_string(), self.doc_type.to_json());

        optional_add!(d, self.doc, "doc");
        optional_add!(d, self.id, "_id");

        Json::Object(d)
    }
}

<%= structs['MoreLikeThisQuery'] %>
<%= to_json_impl('MoreLikeThisQuery') %>

<%= structs['NestedQuery'] %>
<%= to_json_impl('NestedQuery') %>

<%= structs['PrefixQuery'] %>

#[derive(Clone)]
pub enum Rewrite {
    ConstantScoreAuto,
    ScoringBoolean,
    ConstantScoreBoolean,
    ConstantScoreFilter,
    TopTerms(i64),
    TopTermsBoost(i64)
}

impl ToJson for Rewrite {
    fn to_json(&self) -> Json {
        match self {
            &Rewrite::ConstantScoreAuto    => "constant_score_auto".to_json(),
            &Rewrite::ScoringBoolean       => "scoring_boolean".to_json(),
            &Rewrite::ConstantScoreBoolean => "constant_score_boolean".to_json(),
            &Rewrite::ConstantScoreFilter  => "constant_score_filter".to_json(),
            &Rewrite::TopTerms(n)          => format!("top_terms_{}", n).to_json(),
            &Rewrite::TopTermsBoost(n)     => format!("top_terms_boost_{}", n).to_json()
        }
    }
}

<%= to_json_inner_impl('PrefixQuery') %>

<%= structs['QueryStringQuery'] %>
<%= to_json_impl('QueryStringQuery') %>

<%= structs['SimpleQueryStringQuery'] %>
<%= to_json_impl('SimpleQueryStringQuery') %>

<%= structs['RangeQuery'] %>
<%= to_json_inner_impl('RangeQuery') %>

<%= structs['RegexpQuery'] %>

#[derive(Clone)]
pub enum Flag {
    All,
    AnyString,
    Complement,
    Intersection,
    Interval,
    None
}

impl ToString for Flag {
    fn to_string(&self) -> String {
        match self {
            &Flag::All => "ALL",
            &Flag::AnyString => "ANYSTRING",
            &Flag::Complement => "COMPLEMENT",
            &Flag::Intersection => "INTERSECTION",
            &Flag::Interval => "INTERVAL",
            &Flag::None => "NONE"
        }.to_string()
    }
}

#[derive(Clone)]
pub struct Flags {
    flags: Vec<Flag>
}

impl Flags {
    pub fn new() -> Flags {
        Flags {
            flags: vec![]
        }
    }

    pub fn add_flag(&mut self, flag: Flag) -> &mut Self {
        self.flags.push(flag);
        self
    }
}

impl ToJson for Flags {
    fn to_json(&self) -> Json {
        Json::String(self.flags.iter().map(|f| f.to_string()).join("|"))
    }
}

<%= to_json_inner_impl('RegexpQuery') %>

<%= structs['SpanFirstQuery'] %>
<%= to_json_impl('SpanFirstQuery') %>

<%= structs['SpanMultiQuery'] %>
<%= to_json_impl('SpanMultiQuery') %>

<%= structs['SpanNearQuery'] %>
<%= to_json_impl('SpanNearQuery') %>

<%= structs['SpanNotQuery'] %>
<%= to_json_impl('SpanNotQuery') %>

<%= structs['SpanOrQuery'] %>
<%= to_json_impl('SpanOrQuery') %>

<%= structs['SpanTermQuery'] %>
<%= to_json_inner_impl('SpanTermQuery') %>

<%= structs['TermQuery'] %>
<%= to_json_inner_impl('TermQuery') %>

<%= structs['TermsQuery'] %>

impl ToJson for TermsQuery {
    fn to_json(&self) -> Json {
        let mut d = BTreeMap::new();
        d.insert(self.field.clone(), self.values.to_json());

        Json::Object(d)
    }
}

<%= structs['WildcardQuery'] %>
<%= to_json_inner_impl('WildcardQuery') %>

// Filters

<%= structs['AndFilter'] %>
<%= to_json_impl('AndFilter') %>

<%= structs['BoolFilter'] %>
<%= to_json_impl('BoolFilter') %>

<%= structs['ExistsFilter'] %>
<%= to_json_impl('ExistsFilter') %>

<%= structs['GeoBoundingBoxFilter'] %>

#[derive(Clone)]
pub enum Location {
    LatLon(f64, f64),
    GeoHash(String)
}

impl ToJson for Location {
    fn to_json(&self) -> Json {
        match self {
            &Location::LatLon(lat, lon) => {
                let mut d = BTreeMap::new();
                d.insert("lat".to_string(), Json::F64(lat));
                d.insert("lon".to_string(), Json::F64(lon));
                Json::Object(d)
            },
            &Location::GeoHash(ref geo_hash) => {
                Json::String(geo_hash.clone())
            }
        }
    }
}

#[derive(Clone)]
pub enum GeoBox {
    Corners(Location, Location),
    Vertices(f64, f64, f64, f64)
}

impl ToJson for GeoBox {
    fn to_json(&self) -> Json {
        let mut d = BTreeMap::new();
        match self {
            &GeoBox::Corners(ref top_left, ref bottom_right) => {
                d.insert("top_left".to_string(), top_left.to_json());
                d.insert("bottom_right".to_string(), bottom_right.to_json());
            },
            &GeoBox::Vertices(ref top, ref left, ref bottom, ref right) => {
                d.insert("top".to_string(), top.to_json());
                d.insert("left".to_string(), left.to_json());
                d.insert("bottom".to_string(), bottom.to_json());
                d.insert("right".to_string(), right.to_json());
            }
        }
        Json::Object(d)
    }
}

impl ToJson for GeoBoundingBoxFilter {
    fn to_json(&self) -> Json {
        let mut d = BTreeMap::new();
        d.insert(self.field.clone(), self.geo_box.to_json());
        self.add_optionals(&mut d);
        self.add_core_optionals(&mut d);
        Json::Object(d)
    }
}

<%= structs['GeoDistanceFilter'] %>

#[derive(Clone)]
pub enum DistanceUnit {
    Mile,
    Yard,
    Feet,
    Inch,
    Kilometer,
    Meter,
    Centimeter,
    Millimeter,
    NauticalMile
}

impl ToString for DistanceUnit {
    fn to_string(&self) -> String {
        match *self {
            DistanceUnit::Mile => "mi",
            DistanceUnit::Yard => "yd",
            DistanceUnit::Feet => "ft",
            DistanceUnit::Inch => "in",
            DistanceUnit::Kilometer => "km",
            DistanceUnit::Meter => "m",
            DistanceUnit::Centimeter => "cm",
            DistanceUnit::Millimeter => "mm",
            DistanceUnit::NauticalMile => "NM"
        }.to_string()
    }
}

#[derive(Clone)]
pub struct Distance {
    amt: f64,
    unit: DistanceUnit
}

impl ToJson for Distance {
    fn to_json(&self) -> Json {
        Json::String(format!("{}{}", self.amt, self.unit.to_string()))
    }
}

<%= simple_value_enum('DistanceType', ['sloppy_arc', 'arc', 'plane']) %>
<%= simple_value_enum('OptimizeBbox', ['memory', 'indexed', 'none']) %>

impl ToJson for GeoDistanceFilter {
    fn to_json(&self) -> Json {
        let mut d = BTreeMap::new();
        d.insert(self.field.clone(), self.location.to_json());
        d.insert("distance".to_string(), self.distance.to_json());
        self.add_optionals(&mut d);
        self.add_core_optionals(&mut d);
        Json::Object(d)
    }
}

<%= structs['GeoPolygonFilter'] %>
<%= to_json_inner_impl('GeoPolygonFilter') %>

<%= structs['GeoShapeFilter'] %>
<%= to_json_inner_impl('GeoShapeFilter') %>

<%= structs['GeohashCellFilter'] %>

#[derive(Clone)]
pub enum Precision {
    Geohash(i64),
    Distance(Distance)
}

impl ToJson for Precision {
    fn to_json(&self) -> Json {
        match self {
            &Precision::Geohash(geohash_precision) => Json::I64(geohash_precision),
            &Precision::Distance(ref distance)     => distance.to_json()
        }
    }
}

impl ToJson for GeohashCellFilter {
    fn to_json(&self) -> Json {
        let mut d = BTreeMap::new();
        d.insert(self.field.clone(), self.location.to_json());
        self.add_optionals(&mut d);
        self.add_core_optionals(&mut d);
        Json::Object(d)
    }
}

<%= structs['HasChildFilter'] %>
<%= to_json_impl('HasChildFilter') %>

<%= structs['HasParentFilter'] %>
<%= to_json_impl('HasParentFilter') %>

<%= structs['IdsFilter'] %>
<%= to_json_impl('IdsFilter') %>

 <%= structs['IndicesFilter'] %>

#[derive(Clone)]
pub enum NoMatchFilter {
    None,
    All,
    Filter(Box<Filter>)
}

impl ToJson for NoMatchFilter {
    fn to_json(&self) -> Json {
        match self {
            &NoMatchFilter::None               => "none".to_json(),
            &NoMatchFilter::All                => "all".to_json(),
            &NoMatchFilter::Filter(ref filter) => filter.to_json()
        }
    }
}

<%= to_json_impl('IndicesFilter') %>

<%= structs['MatchAllFilter'] %>
<%= to_json_impl('MatchAllFilter') %>
