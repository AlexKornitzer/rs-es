// Query DSL - autogenerated at: <%= Time.now %>

use std::collections::BTreeMap;

use rustc_serialize::json::{Json, ToJson};

<%= enums['Query'] %>

<%= enums['Filter'] %>

macro_rules! with {
    ($funcn:ident, $sn:ident, $t:ty) => {
        pub fn $funcn<'a>(&'a mut self, value: $t) -> &'a mut Self {
            self.$sn = Some(value);
            self
        }
    }
}

macro_rules! optional_add {
    ($map:ident, $sn:expr, $field:expr) => {
        match $sn {
            Some(ref value) => { $map.insert($field.to_string(), value.to_json()); }
            _               => ()
        }
    }
}

// Match queries

<%= simple_value_enum('ZeroTermsQuery', ['none', 'all']) %>

#[derive(Clone)]
pub enum Fuzziness {
    Auto,
    LevenshteinDistance(i64),
    Proportionate(f64)
}

impl ToJson for Fuzziness {
    fn to_json(&self) -> Json {
        use self::Fuzziness::{Auto, LevenshteinDistance, Proportionate};
        match self {
            &Auto                      => "auto".to_json(),
            &LevenshteinDistance(dist) => dist.to_json(),
            &Proportionate(prop)       => prop.to_json()
        }
    }
}

<%= simple_value_enum('MatchType', ['phrase', 'phrase_prefix']) %>

<%= simple_value_enum('MatchQueryType', ['best_fields',
                                         'most_fields',
                                         'cross_fields',
                                         'phrase',
                                         'phrase_prefix']) %>

// Option structs for Query(ies)

#[derive(Clone)]
pub struct MatchAllQuery;

impl MatchAllQuery {
    pub fn build(self) -> Query {
        MatchAll(self)
    }
}

impl ToJson for MatchAllQuery {
    fn to_json(&self) -> Json {
        Json::Object(BTreeMap::new())
    }
}

<%= structs['MatchQuery'] %>

impl ToJson for MatchQuery {
    fn to_json(&self) -> Json {
        let mut inner = BTreeMap::new();
        inner.insert("query".to_string(), self.query.clone());

        self.add_optionals(&mut inner);

        let mut d = BTreeMap::new();
        d.insert(self.field.clone(), Json::Object(inner));

        Json::Object(d)
    }
}

<%= structs['MultiMatchQuery'] %>
<%= to_json_impl('MultiMatchQuery') %>

<%= structs['BoolQuery'] %>
<%= to_json_impl('BoolQuery') %>

<%= structs['BoostingQuery'] %>
<%= to_json_impl('BoostingQuery') %>

<%= structs['CommonQuery'] %>

#[derive(Clone)]
pub enum MinimumShouldMatch {
    Num(i64),
    LowHigh(i64, i64)
}

impl ToJson for MinimumShouldMatch {
    fn to_json(&self) -> Json {
        match self {
            &MinimumShouldMatch::Num(val) => val.to_json(),
            &MinimumShouldMatch::LowHigh(low, high) => {
                let mut d = BTreeMap::new();
                d.insert("low_freq".to_string(), low.to_json());
                d.insert("high_freq".to_string(), high.to_json());
                Json::Object(d)
            }
        }
    }
}

impl ToJson for CommonQuery {
    fn to_json(&self) -> Json {
        let mut d = BTreeMap::new();
        let mut inner = BTreeMap::new();
        inner.insert("query".to_string(), self.query.clone());
        self.add_optionals(&mut inner);
        d.insert("body".to_string(), inner.to_json());
        Json::Object(d)
    }
}

<%= structs['ConstantScoreQuery'] %>
<%= to_json_impl('ConstantScoreQuery') %>

<%= structs['DisMaxQuery'] %>
<%= to_json_impl('DisMaxQuery') %>

<%= structs['FilteredQuery'] %>

#[derive(Clone)]
pub enum Strategy {
    LeapFrogQueryFirst,
    LeapFrogFilterFirst,
    QueryFirst,
    RandomAccess(i64),
    RandomAccessAlways
}

impl ToJson for Strategy {
    fn to_json(&self) -> Json {
        match self {
            &Strategy::LeapFrogQueryFirst  => "leap_frog_query_first".to_json(),
            &Strategy::LeapFrogFilterFirst => "leap_frog_filter_first".to_json(),
            &Strategy::QueryFirst          => "query_first".to_json(),
            &Strategy::RandomAccess(amt)   => format!("random_access_{}", amt).to_json(),
            &Strategy::RandomAccessAlways  => "random_access_always".to_json()
        }
    }
}

<%= to_json_impl('FilteredQuery') %>

<%= structs['FuzzyLikeThisQuery'] %>
<%= to_json_impl('FuzzyLikeThisQuery') %>

<%= structs['FuzzyLikeThisFieldQuery'] %>

impl ToJson for FuzzyLikeThisFieldQuery {
    fn to_json(&self) -> Json {
        let mut d = BTreeMap::new();
        let mut inner = BTreeMap::new();
        inner.insert("like_text".to_string(), self.like_text.to_json());
        self.add_optionals(&mut inner);
        d.insert(self.field.clone(), Json::Object(inner));
        Json::Object(d)
    }
}

// Filters

<%= structs['AndFilter'] %>
<%= to_json_impl('AndFilter') %>
