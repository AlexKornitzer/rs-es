// Query DSL - autogenerated (unless you're reading this in query.rs.erb, which is the source)

use std::collections::BTreeMap;

use rustc_serialize::json::{Json, ToJson};

<%= enums['Query'] %>

macro_rules! with {
    ($funcn:ident, $sn:ident, $t:ident) => {
        pub fn $funcn<'a>(&'a mut self, value: $t) -> &'a mut Self {
            self.$sn = Some(value);
            self
        }
    }
}

macro_rules! optional_add {
    ($map:ident, $sn:expr, $field:expr) => {
        match $sn {
            Some(ref value) => { $map.insert($field.to_string(), value.to_json()); }
            _               => ()
        }
    }
}

// Match queries

#[derive(Clone)]
pub enum ZeroTermsQuery {
    None,
    All
}

impl ToJson for ZeroTermsQuery {
    fn to_json(&self) -> Json {
        match self {
            &ZeroTermsQuery::None => "none".to_json(),
            &ZeroTermsQuery::All  => "all".to_json()
        }
    }
}

#[derive(Clone)]
pub enum Fuzziness {
    Auto,
    LevenshteinDistance(i64),
    Proportionate(f64)
}

impl ToJson for Fuzziness {
    fn to_json(&self) -> Json {
        use self::Fuzziness::{Auto, LevenshteinDistance, Proportionate};
        match self {
            &Auto                      => "auto".to_json(),
            &LevenshteinDistance(dist) => dist.to_json(),
            &Proportionate(prop)       => prop.to_json()
        }
    }
}

#[derive(Clone)]
pub enum MatchType {
    Phrase,
    PhrasePrefix
}

impl ToJson for MatchType {
    fn to_json(&self) -> Json {
        use self::MatchType::{Phrase, PhrasePrefix};
        match self {
            &Phrase =>       "phrase".to_json(),
            &PhrasePrefix => "phrase_prefix".to_json()
        }
    }
}

// Option structs for Query(ies)

pub struct MatchAllQuery;

impl MatchAllQuery {
    pub fn build(self) -> Query {
        MatchAll(self)
    }
}

impl ToJson for MatchAllQuery {
    fn to_json(&self) -> Json {
        Json::Object(BTreeMap::new())
    }
}

<%= structs['MatchQuery'] %>

impl ToJson for MatchQuery {
    fn to_json(&self) -> Json {
        let mut inner = BTreeMap::new();
        inner.insert("query".to_string(), self.query.clone());

        self.add_optionals(&mut inner);

        let mut d = BTreeMap::new();
        d.insert(self.field.clone(), Json::Object(inner));

        Json::Object(d)
    }
}

#[derive(Clone)]
pub enum MatchQueryType {
    BestFields,
    MostFields,
    CrossFields,
    Phrase,
    PhrasePrefix
}

impl ToJson for MatchQueryType {
    fn to_json(&self) -> Json {
        use self::MatchQueryType::{BestFields,
                                   MostFields,
                                   CrossFields,
                                   Phrase,
                                   PhrasePrefix};
        match self {
            &BestFields   => "best_fields".to_json(),
            &MostFields   => "most_fields".to_json(),
            &CrossFields  => "cross_fields".to_json(),
            &Phrase       => "phrase".to_json(),
            &PhrasePrefix => "phrase_prefix".to_json()
        }
    }
}

<%= structs['MultiMatchQuery'] %>

impl ToJson for MultiMatchQuery {
    fn to_json(&self) -> Json {
        let mut d = BTreeMap::new();
        d.insert("query".to_string(), self.query.clone());
        d.insert("fields".to_string(), self.fields.to_json());

        self.add_optionals(&mut d);

        Json::Object(d)
    }
}
